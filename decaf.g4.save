lgrammar decaf;

/*------------------------------------------------------------------
 * LEXER RULES 
 *------------------------------------------------------------------*/
 
ID	:	 LETTER (LETTER|DIGIT)*    		;

NUM	:	DIGIT(DIGIT)*			;

CHAR                   :	'\''  LETTER  '\'' 			;
 
fragment DIGIT	 :	'0'..'9'			;

fragment  LETTER  :	('a'..'z'|'A'..'Z'|'_')		;

WHI: ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ ;

/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/
 
program:	'class'  'Program' '{' (declaration)* '}'		;
  
declaration
	:	 varDeclaration| methodDeclaration 	;
	
varDeclaration 
	:	mType  ID  varDeclaration1 ';'  ;
	
varDeclaration1
	:	 '[' NUM ']' | 	;
	
methodDeclaration
	:	mType ID '(' (parameter (',' parameter)*)*   ')'  block;
			
mType
	:	('int')| ('char' )| ('boolean') |( 'void');
	
parameter
	:	 mType ID ('['  ']')?;
	
block	:	'{'  (varDeclaration)*  (statement)* '}';

statement
	:	block 
		| 'if' '(' expression ')' block blockL
		| 'while' '(' expression ')' block
		| 'return' expressionL ':'
		| location '=' expression
		| expressionL ';'
	;
	
blockL	:	'else' block;	
expressionL	:	expression | ;

expression 
	:	relExp (cond_op expression | );
	
relExp	
	:	sumaExp (rel_op relExp | );

sumaExp	
	:	multiExp ( suma_op sumaExp | );
	
multiExp	
	:	negadorExp (mul_op multiExp | );
	
negadorExp
	:	'-' val | '!' val | val;
	
cond_op	
	:	'&&' | '||';
	
rel_op	
	:	'<=' | '<'  | '>' | '>='  | eq_op;
	
eq_op	:	'==' | '!=';

suma_op	:	'+' | '-';

mul_op	:	'*' |
